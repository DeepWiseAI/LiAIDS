from nodule_det.bound3d import Bound3D, combine_bounds_3d_direct
import numpy as np
from nodule_det.ct_utils.bbox import bbox3d_iom, bbox3d_iou

def convert_from_cls_format(cls_boxes, cls_segms, cls_keyps, num_classes):
    """Convert from the class boxes/segms/keyps format generated by the testing
    code.
    """
    box_list = [b for b in cls_boxes if len(b) > 0]
    if len(box_list) > 0:
        boxes = np.concatenate(box_list)
    else:
        boxes = None
    if cls_segms is not None:
        segms = [s for slist in cls_segms for s in slist]
    else:
        segms = None
    if cls_keyps is not None:
        keyps = [k for klist in cls_keyps for k in klist]
    else:
        keyps = None
    classes = []
    for j in range(num_classes):
        classes += [j+1] * len(cls_boxes[j])
    return boxes, segms, keyps, classes

def xyxy_to_xywh(xyxy):
    """Convert [x1 y1 x2 y2] box format to [x1 y1 w h] format."""
    if isinstance(xyxy, (list, tuple)):
        # Single box given as a list of coordinates
        assert len(xyxy) == 4
        x1, y1 = xyxy[0], xyxy[1]
        w = xyxy[2] - x1 + 1
        h = xyxy[3] - y1 + 1
        return (x1, y1, w, h)
    elif isinstance(xyxy, np.ndarray):
        # Multiple boxes given as a 2D ndarray
        return np.hstack((xyxy[:, 0:2], xyxy[:, 2:4] - xyxy[:, 0:2] + 1))
    else:
        raise TypeError('Argument xyxy must be a list, tuple, or numpy array.')

def combine_slice_level_pred(results_dict, thresh, cls_num=15, max_slices_stride=5, iom_thresh=0.7, iou_thresh3d=0.2):
    """ Group slice level bounds (x,y,w,h,slice_idx,label,score) into bound3d. """

    combine_opt = {}
    # is per-class-threshold difined
    if isinstance(thresh, list):
        thresh_list = thresh
    else:
        thresh_list = [thresh for _ in range(cls_num)]
    label_combine_matrix = np.ones((cls_num, cls_num), dtype='int32') * -1
    label_combine_matrix[range(1,cls_num), range(1,cls_num)] = range(1,cls_num)
    least_inter_ratio_matrix = np.zeros((cls_num, cls_num), dtype='float32')
    least_inter_ratio_matrix[range(1,cls_num), range(1,cls_num)] = np.ones((cls_num-1), dtype='float32') * iom_thresh

    combine_opt['label_combine_matrix'] = label_combine_matrix
    combine_opt['least_inter_ratio_matrix'] = least_inter_ratio_matrix
    combine_opt['max_slices_stride'] = max_slices_stride

    bound2d_list = []
    for slice_idx, slice_pred in results_dict.items():
        _, _ , cls_boxes = slice_pred
        _,_,_, classes = convert_from_cls_format(
            cls_boxes, None, None, cls_num - 1)
        #print(len(cls_boxes), cls_boxes[0])
        im_results = np.vstack([cls_boxes[j] for j in range(cls_num-1)])
        boxes = im_results[:, :-1]
        scores = im_results[:, -1]
        for idx, score in enumerate(scores):
            x, y, w, h = xyxy_to_xywh(boxes[idx, :].tolist())
            # if score >= thresh_list[classes[idx]] or (w*h < 225 and score >= 0.0125):
            if score >= thresh_list[classes[idx]]:
            #     x, y, w, h = xyxy_to_xywh(boxes[idx, :].tolist())
                bound2d_list.append([x, y, w, h, slice_idx, classes[idx], score])
    bound_groups = combine_bounds_3d_direct(bound2d_list, combine_opt)

    bound3ds = []
    direct = 0
    for bound_group in bound_groups:
        bound3d = Bound3D()
        for bound2d in bound_group:
            x, y, w, h, slice_id, label, score = bound2d
            cube = [x, y, slice_id, w, h, 1]
            bound3d.append(cube, direct, label, score, combine_opt['label_combine_matrix'])
            if not bound3d.is_valid:
                return None
        bound3d.set_avg_score(len(bound_group))
        bound3ds.append(bound3d)
        #print(bound3d)

    bound_groups, bound3ds = post_process_by_3diom(bound_groups, bound3ds, iou_thresh3d)
    # print(len(bound_groups), len(bound3ds))
    return bound_groups, bound3ds

def post_process_by_3diom(bound_groups, bound3ds, iom_thresh=0.5, iou_thresh3d=0.2):
    bound_groups = [x for (x, _) in zip(bound_groups, bound3ds) if _.avg_score >= iou_thresh3d]
    bound3ds = [_ for _ in bound3ds if _.avg_score >= iou_thresh3d]

    if len(bound3ds) <= 1:
        return bound_groups, bound3ds

    res = []
    items = [(b1, b2) for b1, b2 in zip(bound_groups, bound3ds)]
    items = sorted(items, key=lambda x: x[1].avg_score, reverse=True)
    res.append(items[0])

    items.pop(0)

    while(len(items) > 0):
        cur = 0
        b_cmp = res[-1]
        cube_cmp = b_cmp[1].cube
        #while(cur < len(items)):
        #    b_cur = items[cur]
        #    cube_cur = b_cur[1].cube
        #    if(bbox3d_iou(cube_cmp, cube_cur) > 0.0):
        #        if bbox3d_iom(cube_cmp, cube_cur) > iom_thresh:
        #            # print('has iom')
        #            items.pop(cur)
        #        else:
        #            cur += 1
        #    else:
        #        cur += 1

        if len(items) > 0:
            res.append(items[0])
            items.pop(0)

    bound_groups = [b[0] for b in res]
    bound3ds = [b[1] for b in res]

    return bound_groups, bound3ds

